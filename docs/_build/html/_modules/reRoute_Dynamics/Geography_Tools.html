

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>reRoute_Dynamics.Geography_Tools &mdash; reRoute_Dynamics 25w16a documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d146563a"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            reRoute_Dynamics
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">reRoute_Dynamics_Core</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">reRoute_Dynamics</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">reRoute_Dynamics.Geography_Tools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for reRoute_Dynamics.Geography_Tools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Geography_Tools.py</span>
<span class="sd">S. Peck</span>

<span class="sd">Geography_Tools.py is a module that contains the methods primarily used in the interpretation</span>
<span class="sd">of geospatial data for the ultimate creation of Route .json files from position and elevation data.</span>

<span class="sd">Methods:</span>
<span class="sd">geodesic_formula() - method to calculate the geodesic distance between two (lat, lon) points.</span>
<span class="sd">compass_heading() - method to determine cardinal compass heading from an angle off of North.</span>
<span class="sd">heading_to_angle() - method to determine the compass degree angle from a cardinal direction.</span>
<span class="sd">point_bearing() - method to determine the travel bearing between two points.</span>
<span class="sd">get_bounding_box() - method to create the smallest possible box that encompasses all the points in a shape.</span>
<span class="sd">interpolate_points() - method to interpolate additional points between two initial geospatial points.</span>
<span class="sd">repeat_id_remover() - method to swap any repeated value in an iterable with -1. </span>
<span class="sd">verbose_line_updater() - method to provide line updates for verbosity</span>
<span class="sd">query_elevation_changes() - method to determine the elevation changes in an iterable of elevation.</span>
<span class="sd">query_stops() - method to assign stops to their closest corresponding point in a geometry series.</span>
<span class="sd">query_signals() - method to assign signals to their closest corresponding point in a geometry series.</span>
<span class="sd">query_distance_traveled() - method to calculate the distance traveled from point to point in a geometry series.</span>
<span class="sd">query_speed_limits() - method to assign speed limits to each point in a geometry series. </span>
<span class="sd">query_bearings() - method to query the bearing to the next point for each point in a geometric series.</span>
<span class="sd">get_rasterfiles() - method to return all standard .tif files in a directory.</span>
<span class="sd">reproject_rasterfiles() - method to reproject and save raster files to a particular geographic projection.</span>
<span class="sd">query_elevation_series() - method to query the elevation from each point in a geometry series using rasterfiles.</span>
<span class="sd">smooth_elevation() - method to use a savisky-golay filter to smooth out elevation changes (or otherwise)</span>
<span class="sd">calculate_grades() - method to calculate the slope grade at each point in a geometry series with elevations</span>
<span class="sd">interpolate_geometry_series() - method to take a whole series of points and interolate extra points if there are significant gaps.</span>
<span class="sd">load_from_json() - method to load a Route object from a saved .json file. </span>

<span class="sd">Classes:</span>
<span class="sd">Route - a class used to store information on a route, like geometry, elevation, signals, limits, and stops. </span>
<span class="sd">save_to_json() - class method used to encode and store a Route class as a .json file</span>
<span class="sd">query_point() - class method used to query the information of a point at an index in the route</span>
<span class="sd">to_gdf() - class method used to convert a Route class&#39;s stored information to a GeoDataFrame.</span>
<span class="sd">    </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">from</span> <span class="nn">alive_progress</span> <span class="kn">import</span> <span class="n">alive_bar</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">rasterio.warp</span> <span class="kn">import</span> <span class="n">calculate_default_transform</span><span class="p">,</span> <span class="n">reproject</span><span class="p">,</span> <span class="n">Resampling</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">pyogrio</span> <span class="k">as</span> <span class="nn">pio</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">geopy.distance</span> <span class="k">as</span> <span class="nn">gdist</span>

<span class="k">def</span> <span class="nf">_haversine_formula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    haversine_formula takex the latitude and longitude of two separate points,</span>
<span class="sd">    and calculates the distance in kilometers between those two points as a crow flies.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    x1 - latitude pt 1 in degrees</span>
<span class="sd">    y1 - longitude pt 1 in degrees</span>
<span class="sd">    x2 - latitude pt 2 in degrees</span>
<span class="sd">    y2 - longitude pt 2 in degrees</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    distance between the points in kilometers.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    11/20/2024 - Efficiency can be improved by having radian conversion be done externally.</span>
<span class="sd">    12/21/2025 - Deprecated. Succeeded by geodesic_formula.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># convert the degree coordinates to radians</span>
    <span class="n">lat1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">lon1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">lat2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">lon2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
    
    <span class="c1"># Get the radius of earth in kilometers - using the average of the radii</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mf">6371.009</span> <span class="c1">#@Great_Circle_Distance</span>
    
    <span class="c1"># calculate the difference in radians</span>
    <span class="n">dlon</span><span class="o">=</span><span class="n">lon2</span><span class="o">-</span><span class="n">lon1</span>
    <span class="n">dlat</span><span class="o">=</span><span class="n">lat2</span><span class="o">-</span><span class="n">lat1</span>
    
    <span class="c1"># calculate the distance using the haversine formula.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>

    <span class="n">distance</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">c</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">geodesic_formula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
    
    
    <span class="c1"># return the distance in km.</span>
    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="mf">.0001</span><span class="p">:</span>
        <span class="n">distance</span><span class="o">=</span><span class="mf">.0001</span>
    <span class="k">return</span> <span class="n">distance</span>


<div class="viewcode-block" id="geodesic_formula">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.geodesic_formula">[docs]</a>
<span class="k">def</span> <span class="nf">geodesic_formula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;geodesic_formula takes the latitude and longitude of two separate points,</span>
<span class="sd">    and calculates the distance in kilometers between those two points as a crow flies,</span>
<span class="sd">    according to the geodesic formula as calculated by geopy. </span>
<span class="sd">    </span>
<span class="sd">    :param x1: latitude of point 1 in degrees</span>
<span class="sd">    :param y1: longitude of point 1 in degrees</span>
<span class="sd">    :param x2: latitude of point 2 in degrees</span>
<span class="sd">    :param y2: longitude of point 2 in degrees</span>
<span class="sd">    </span>
<span class="sd">    :return: </span>
<span class="sd">        Distance between the points in kilometers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gdist</span><span class="o">.</span><span class="n">geodesic</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">))</span><span class="o">.</span><span class="n">km</span></div>

    
    

<div class="viewcode-block" id="compass_heading">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.compass_heading">[docs]</a>
<span class="k">def</span> <span class="nf">compass_heading</span><span class="p">(</span><span class="n">bearing</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compass_heading converts a bearing in degrees to a</span>
<span class="sd">    compass value like North, South, or East.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    bearing - the bearing value, in degrees, as float.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    string representation of compass heading.</span>
<span class="sd">    </span>
<span class="sd">    Notes: </span>
<span class="sd">    11/18/2024 - There is a more mathematically elegant solution to this, but I&#39;m not bothering with it right now.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># set up a list of possible compass directions</span>
    <span class="n">possible_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;NE&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;SE&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;SW&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;NW&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">]</span>
    
    <span class="c1"># get the index of the 45 quadrants the angle bearing is in</span>
    <span class="n">bearing_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">bearing</span><span class="o">/</span><span class="mi">45</span><span class="p">))</span>
    
    <span class="c1"># make sure the index isn&#39;t negative</span>
    <span class="k">if</span> <span class="n">bearing_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bearing_index</span><span class="o">=</span><span class="n">bearing_index</span><span class="o">+</span><span class="mi">8</span>
    <span class="k">elif</span> <span class="n">bearing_index</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">bearing_index</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">bearing_index</span> <span class="o">-=</span> <span class="mi">8</span>
        
    <span class="c1"># return the corresponding compass direction</span>
    <span class="k">return</span> <span class="n">possible_dirs</span><span class="p">[</span><span class="n">bearing_index</span><span class="p">]</span></div>



<div class="viewcode-block" id="heading_to_angle">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.heading_to_angle">[docs]</a>
<span class="k">def</span> <span class="nf">heading_to_angle</span><span class="p">(</span><span class="n">heading</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    heading_to_angle() takes a compass heading of 8 directions,</span>
<span class="sd">    and converts it to an angle in degrees. </span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    heading - a string representing heading.</span>
<span class="sd">    </span>
<span class="sd">    Returns: a compass bearing angle as float.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;NE&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;SE&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;SW&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;NW&quot;</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">heading</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="o">*</span><span class="mi">360</span><span class="p">)</span></div>

    
    

<div class="viewcode-block" id="point_bearing">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.point_bearing">[docs]</a>
<span class="k">def</span> <span class="nf">point_bearing</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">bearing_type</span> <span class="o">=</span> <span class="s2">&quot;Angle&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    point_bearing takex in the latitude and longitude of two separate ponts,</span>
<span class="sd">    and calculates the bearing when travelling from point 1 and point 2.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    x1 - latitude pt 1 in degrees</span>
<span class="sd">    y1 - longitude pt 1 in degrees</span>
<span class="sd">    x2 - latitude pt 2 in degrees</span>
<span class="sd">    y2 - longitude pt 2 in degrees</span>
<span class="sd">    bearing_type - determine the bearing output. Options: Angle - return the angle in degrees. Compass - return the angle as a directional bearing (eg: N, E, S, W)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    bearing of the vector between the two points. </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to radians</span>
    <span class="n">lat1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">lon1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">lat2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">lon2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
    
    <span class="c1"># run the bearing calculation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon2</span><span class="o">-</span><span class="n">lon1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon2</span><span class="o">-</span><span class="n">lon1</span><span class="p">)</span>
    <span class="n">bearing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">bearing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">bearing</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">bearing</span><span class="o">+=</span><span class="mi">360</span>
    <span class="k">while</span> <span class="n">bearing</span><span class="o">&gt;</span><span class="mi">360</span><span class="p">:</span>
        <span class="n">bearing</span><span class="o">-=</span><span class="mi">360</span>
    
    <span class="c1"># check the return type</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bearing_type</span> <span class="o">==</span> <span class="s2">&quot;Angle&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bearing</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">bearing_type</span> <span class="o">==</span> <span class="s2">&quot;Compass&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">compass_heading</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_bounding_box">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.get_bounding_box">[docs]</a>
<span class="k">def</span> <span class="nf">get_bounding_box</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;basic&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get_bounding_box() takes in a shapely shape,</span>
<span class="sd">    and then generates a polygon that is a rectangular bounding box.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    shape: any shapely shape</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">    shapely.polygon that fits around the provided shape</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">how</span><span class="o">==</span><span class="s1">&#39;basic&#39;</span><span class="p">:</span>
        <span class="c1"># get the bound coordinates</span>
        <span class="n">bbox_cords</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">bounds</span>

        <span class="c1"># create a rectangle of those coordinates</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="p">((</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                     <span class="p">(</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                     <span class="p">(</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                     <span class="p">(</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># return a shapely polygon of those coordinates</span>
        <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">how</span><span class="o">==</span><span class="s1">&#39;swapax&#39;</span><span class="p">:</span>
        <span class="c1"># get the bound coordinates</span>
        <span class="n">bbox_cords</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">bounds</span>

        <span class="c1"># create a rectangle of those coordinates</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="p">((</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="p">(</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="p">(</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                     <span class="p">(</span><span class="n">bbox_cords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_cords</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="c1"># return a shapely polygon of those coordinates</span>
        <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">)</span></div>

        


<div class="viewcode-block" id="interpolate_points">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.interpolate_points">[docs]</a>
<span class="k">def</span> <span class="nf">interpolate_points</span><span class="p">(</span><span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    interpolate_points takes two shapely points and a maximum distance,</span>
<span class="sd">    and then interpolates between the points if the maximum distance is exceeded.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    point_1 - starting point as a shapely point of lat, lon</span>
<span class="sd">    point_2 - final point as a shapely point of lat, lon</span>
<span class="sd">    max_dist - maximum distance the points can be without interpolation. Default int of 1.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    an iterable of lon,lat shapely points. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># get distance in meters</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">geodesic_formula</span><span class="p">(</span><span class="n">point_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point_1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">point_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point_2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span>
    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">max_dist</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">point_1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># calculate the number of points between to be interpolated</span>
        <span class="n">num_interp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">distance</span><span class="o">/</span><span class="n">max_dist</span><span class="p">))</span>
        
        <span class="c1"># calculate the distance between each interpolated point</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">distance</span><span class="o">/</span><span class="n">num_interp</span>
        
        <span class="c1"># generate a linestring</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">([</span><span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">])</span>
        
        <span class="c1"># create the points list with the initial point</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_1</span><span class="p">]</span>
        <span class="c1">#print(dx,distance,num_interp)</span>
        
        <span class="c1"># loop through each distance from the origin </span>
        <span class="k">for</span> <span class="n">dis</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="n">distance</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dx</span><span class="o">/</span><span class="n">distance</span><span class="p">):</span>
            
            <span class="c1"># interpolate a point</span>
            <span class="n">i_point</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[:][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># convert it to a shapely point</span>
            <span class="n">i_point</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">i_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c1"># append the point</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_point</span><span class="p">)</span>
            
        <span class="c1"># return the points</span>
        <span class="k">return</span> <span class="n">points</span></div>

    
    
<div class="viewcode-block" id="repeat_id_remover">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.repeat_id_remover">[docs]</a>
<span class="k">def</span> <span class="nf">repeat_id_remover</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    repeat_id_remover takes an iterable of IDs where -1 is invalid,</span>
<span class="sd">    and swaps out any repeat index with an invalid.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    sequence - a sequence of id values in an iterable.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    sequence with repeated values swapped for a -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># start the sequence with invalid</span>
    <span class="n">sequence_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># build a list for the new sequence</span>
    <span class="n">new_sequence</span> <span class="o">=</span> <span class="n">sequence</span>
    
    <span class="c1"># creaate a history</span>
    <span class="n">his</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    
    <span class="c1"># loop through each element in the sequence</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_sequence</span><span class="p">):</span>
        
        <span class="c1"># if the element is in the history, </span>
        <span class="k">if</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">his</span><span class="p">:</span>
            <span class="c1"># swap the index with the sequence value</span>
            <span class="n">new_sequence</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence_value</span>
        
        <span class="c1"># then, add the element to the history. </span>
        <span class="n">his</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
        
    
    <span class="c1"># return the new sequence</span>
    <span class="k">return</span> <span class="n">new_sequence</span></div>



<span class="c1">### ---- SERIES QUERY METHODS ---- ###</span>

<span class="k">def</span> <span class="nf">_flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flips the x and y coordinate values&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>

<div class="viewcode-block" id="verbose_line_updater">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.verbose_line_updater">[docs]</a>
<span class="k">def</span> <span class="nf">verbose_line_updater</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    verbose_line_updater generates a verbose message with timestamps and</span>
<span class="sd">    method calls based on a passed message. Can reset printline if specified.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    message - message, as str, to be printed with the line.</span>
<span class="sd">    reset - boolean to reset carrige or not. Default false.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    The string to be printed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># generate the string.</span>
    <span class="n">data_string</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">{}</span><span class="s2"> -- </span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2">()] </span><span class="si">{}</span><span class="s2">                  &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                                                <span class="s2">&quot;Geography_Tools&quot;</span><span class="p">,</span>
                                                                <span class="nb">str</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]),</span>
                                                                <span class="n">message</span><span class="p">)</span>
    <span class="c1"># check if the carrage should be reset.</span>
    <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_string</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_string</span><span class="p">)</span>
        
    <span class="c1"># return the carrage.</span>
    <span class="k">return</span> <span class="n">data_string</span></div>



<div class="viewcode-block" id="query_elevation_changes">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_elevation_changes">[docs]</a>
<span class="k">def</span> <span class="nf">query_elevation_changes</span><span class="p">(</span><span class="n">elev</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_elevation_change takes an iterable of elevation,</span>
<span class="sd">    and returns the elevation change between the point at the</span>
<span class="sd">    current index, and the next poinnt. </span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    elev - iterable of elevation data</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of elevation changes to reach the next point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># convert to series</span>
    <span class="n">elev_ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">elev</span><span class="p">)</span>
    
    <span class="c1"># shift the series by one</span>
    <span class="n">shifted</span> <span class="o">=</span> <span class="n">elev_ser</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># get the original final point</span>
    <span class="n">final_point</span> <span class="o">=</span> <span class="n">elev</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># set the final point to replace the nan</span>
    <span class="n">shifted</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_point</span>
    
    <span class="c1"># calculate the shift between the elevations and return.</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">elev_ser</span><span class="o">-</span><span class="n">shifted</span><span class="p">)</span></div>

    
    
<div class="viewcode-block" id="query_stops">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_stops">[docs]</a>
<span class="k">def</span> <span class="nf">query_stops</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">stop_table_path</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;stop_id&#39;</span><span class="p">,</span> <span class="n">epsg_from</span> <span class="o">=</span> <span class="mi">4326</span><span class="p">,</span> <span class="n">epsg_to</span><span class="o">=</span><span class="mi">4326</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_stops takes in a geometry point series for a given route, and a path to</span>
<span class="sd">    all stop ids and geometry, and then returns a list of stop id&#39;s in the order the</span>
<span class="sd">    bus will arrive.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    geometry - a series of shapely points representing longitude and latitude</span>
<span class="sd">    stop_table_path - a path to the dataset containing stop geodata csv, as str</span>
<span class="sd">    key - column identifier for the stop id (or whatever value you want) as str</span>
<span class="sd">    epsg_from - the epsg projection the csv is in as an int, default is 4326</span>
<span class="sd">    epsg_to - the epsg projection the data should be reporojected to as an int, default is 4326</span>
<span class="sd">    margin - distance, in meters, that the stop is allowed to be from a given point to qualify, as int.</span>
<span class="sd">    verbose - boolean to enable verbosity. default False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of stop ids (or other queried values from the data), with invalid points being labeled -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Check the shape boundaries for the geometric series</span>
    <span class="n">shape_bounds</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">))</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">3e-4</span><span class="p">)</span>
    
    <span class="c1"># read the data.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loading CSV: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stop_table_path</span><span class="p">))</span>
    <span class="n">stop_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">stop_table_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loaded CSV.&quot;</span><span class="p">)</span>
    
    <span class="c1"># convert the data to a shapely geometry pandas series</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loading stop geometry...&quot;</span><span class="p">)</span>
    <span class="n">stop_table</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop_table</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">stop_lat</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">stop_lon</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loaded stop geometry.&quot;</span><span class="p">)</span>
    
    <span class="c1">#print(stop_table[&#39;geometry&#39;])</span>
    <span class="c1"># convert the data to a geodataframe, and re-set the crs to the specified</span>
    <span class="k">if</span> <span class="n">epsg_from</span> <span class="o">!=</span> <span class="n">epsg_to</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Setting geodata: epsg</span><span class="si">{}</span><span class="s2">--&gt;epsg:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epsg_from</span><span class="p">,</span> <span class="n">epsg_to</span><span class="p">))</span>
        <span class="n">stop_table</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">stop_table</span><span class="p">)</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg_from</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg_to</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stop_table</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">stop_table</span><span class="p">)</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg_from</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Geodata Set.&quot;</span><span class="p">)</span>
    
    <span class="c1"># filter the stop table to only be the stops within the boundary</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Filtering stops...&quot;</span><span class="p">)</span>
    <span class="n">stop_table</span> <span class="o">=</span> <span class="n">stop_table</span><span class="p">[</span><span class="n">stop_table</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shape_bounds</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Stops filtered.&quot;</span><span class="p">)</span>

    <span class="c1"># check for stops within a set distance of each geometry point</span>
    <span class="n">stop_id_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Processing stops...&quot;</span><span class="p">)</span>
    <span class="c1"># loop through the geimetry</span>
    
    <span class="c1">#with alive_bar(len(geometry)) as bar:</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">):</span>

        <span class="c1"># re-set the pont name because i dont want to re-change them all</span>
        <span class="n">route_pt</span> <span class="o">=</span> <span class="n">point</span>

        <span class="c1"># get the distances using the geodesic formula, converted to meters</span>
        <span class="n">stop_table</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop_table</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">geodesic_formula</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">route_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">route_pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
        <span class="c1"># filter the data to yeild the closest stop</span>
        <span class="n">closest_stop</span> <span class="o">=</span> <span class="n">stop_table</span><span class="p">[</span><span class="n">stop_table</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stop_table</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># if the closest stop is within the margin, append it to the list. Otherwise, append -1.</span>
        <span class="n">stop_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">closest_stop</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">margin</span><span class="p">)</span><span class="o">*</span><span class="n">closest_stop</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">closest_stop</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">margin</span><span class="p">))</span>
            <span class="c1">#bar()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Stops processed. Returning values.&quot;</span><span class="p">)</span>
    
    <span class="c1"># return the stop id list with repeats removed, and the last index guaranteed to be a stop.</span>
    <span class="k">return</span> <span class="n">repeat_id_remover</span><span class="p">(</span><span class="n">stop_id_list</span><span class="p">)</span></div>



<div class="viewcode-block" id="query_distance_traveled">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_distance_traveled">[docs]</a>
<span class="k">def</span> <span class="nf">query_distance_traveled</span><span class="p">(</span><span class="n">geometry_series</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_distance_traveled takes in a series of points,</span>
<span class="sd">    and then calculates the distance traveled from point to point, in kilometers.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    geometry_series - a series of shapely points of lat and lon.</span>
<span class="sd">    verbose - boolean to enable verbosity. default False.</span>

<span class="sd">    Returns:</span>
<span class="sd">    an iterable representing the change in distance between each point and the next.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get the current geometry series</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loading geometry.&quot;</span><span class="p">)</span>
    <span class="n">currents</span> <span class="o">=</span> <span class="n">geometry_series</span>
    
    <span class="c1"># shift the geometry series up by one, which will be the next ponts.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Shifting geometry.&quot;</span><span class="p">)</span>
    <span class="n">nexts</span> <span class="o">=</span> <span class="n">geometry_series</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># combine the two into a dataframe.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Combining geometry.&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">currents</span><span class="p">,</span> <span class="n">nexts</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># get the final point and make sure it&#39;s the last value.</span>
    <span class="n">final_point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># set the nan value in the beginning of the &#39;nexts&#39; to the initial, representing no distance traveled.</span>
    <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">final_point</span>

    <span class="c1"># apply the geodesic formula to the data, which will yeild a series of changes in distance.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Calculating distances.&quot;</span><span class="p">)</span>
    <span class="n">dXs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">geodesic_formula</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Point distances processed. Returning values.&quot;</span><span class="p">)</span>

    <span class="c1"># return the series of the changes in distance, in km, make sure it never doesn&#39;t travel.</span>
    <span class="k">return</span> <span class="n">dXs</span><span class="o">.</span><span class="n">values</span></div>



<div class="viewcode-block" id="query_signals">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_signals">[docs]</a>
<span class="k">def</span> <span class="nf">query_signals</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">signal_data_path</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;SIGNAL_ID&quot;</span><span class="p">,</span> <span class="n">epsg</span> <span class="o">=</span> <span class="mi">4326</span><span class="p">,</span> <span class="n">margin</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_signals takes in a geometric series of shapely points,</span>
<span class="sd">    a path to stoplight signal data, and returns a list of the signal id at</span>
<span class="sd">    each point in that series.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    geometry - a series of shapely points of lat and lon.</span>
<span class="sd">    signal_data_path - path, as str, to a shapefile containing stop signal data.</span>
<span class="sd">    key - the column identifier of signal id (or other target value) to be queried</span>
<span class="sd">    epsg - the epsg the data will be re-set as. Default is 4326.</span>
<span class="sd">    margin - the distance, in meters, that the signal is allowed to be from a given point to qualify.</span>
<span class="sd">    verbose - boolean to enable verbosity. Default False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of signal IDs, or other info about the signal, as specified.</span>
<span class="sd">    -1 if none found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># get the bounding box of the geometry</span>
    <span class="n">shape_bounds</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">))</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">3e-3</span><span class="p">)</span>
    
    <span class="c1"># Get the signal data.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loading shapefile &amp; setting EPSG: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_data_path</span><span class="p">))</span>
    <span class="n">signals</span> <span class="o">=</span> <span class="n">pio</span><span class="o">.</span><span class="n">read_dataframe</span><span class="p">(</span><span class="n">signal_data_path</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg</span><span class="p">)</span>
    <span class="n">signals</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">signals</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">_flip</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Shapefile laded with EPSG:</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epsg</span><span class="p">))</span>
    <span class="c1"># get the signals that are within the bounds of the data.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Filtering sinals...&quot;</span><span class="p">)</span>
    <span class="n">signals</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="n">signals</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shape_bounds</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">geometry</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Signals filtered.&quot;</span><span class="p">)</span>

    <span class="c1"># Generate empty list for signal ids</span>
    <span class="n">signal_id_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># loop through the geometry</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Processing signals...&quot;</span><span class="p">)</span>
<span class="c1">#with alive_bar(len(geometry)) as bar:</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># use the geodesic formula to get the distances between the current point and each point in the series, in meters</span>
            <span class="n">signals</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">signals</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">geodesic_formula</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
            <span class="c1"># get the closest signal through the minimum distance</span>
            <span class="n">closest_signal</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="n">signals</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">signals</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># check if the signal is within the margin, and if so, append it to the list. If not, append -1.</span>

            <span class="n">signal_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">closest_signal</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">])</span><span class="o">&lt;</span><span class="n">margin</span><span class="p">)</span><span class="o">*</span><span class="n">closest_signal</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">closest_signal</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">margin</span><span class="p">)))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">signal_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1">#verbose_line_updater(&quot;No signal data in bounds.&quot;)</span>
            <span class="c1">#bar()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Signals processed. Returning values.&quot;</span><span class="p">)</span>
    
    <span class="c1"># return the list.</span>
    <span class="k">return</span> <span class="n">repeat_id_remover</span><span class="p">(</span><span class="n">signal_id_list</span><span class="p">)</span></div>




<div class="viewcode-block" id="query_speed_limits">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_speed_limits">[docs]</a>
<span class="k">def</span> <span class="nf">query_speed_limits</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">limit_data_path</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;SPEED_LIM&quot;</span><span class="p">,</span> <span class="n">epsg</span> <span class="o">=</span> <span class="mi">4326</span><span class="p">,</span> <span class="n">margin</span> <span class="o">=</span> <span class="mf">3e-4</span><span class="p">,</span> <span class="n">last_known_limit</span><span class="o">=</span> <span class="mi">20</span><span class="o">*</span><span class="mf">0.00044704</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_speed_limits takes a geometric iterable of shapely points,</span>
<span class="sd">    a path to speed limit geodata, and returns the corresponding speed limits at</span>
<span class="sd">    each point.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    geometry - a series of shapely points of lat and lon</span>
<span class="sd">    limit_data_path - path to shapefile of speed limit data as str</span>
<span class="sd">    key - column identifier of a speed limit or other value as str, assumed to be an int in units of mph</span>
<span class="sd">    margin - distance a point can be from the street to qualify, default 5e-5</span>
<span class="sd">    last_known_limit - the speed limit int value that the bus will assumedly start at or above. default 20 mph</span>
<span class="sd">    verbose - boolean to enable verbosity. Default False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of speed limits corresponding to the geometry.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    11/13/2024 - This can be adjusted such that instead of the first value, it&#39;s the true closest. Also can probably be combined with the other queries in such a way that it reduces individual methods. FIXED -- 11/19/2024</span>
<span class="sd">    11/18/2024 - Currently Broken. - FIXED -- 11/19/2024</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># DEPENDING ON THE FILE, THIS CAN TAKE A WHILE.</span>
    
    <span class="n">geometry</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">_flip</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    
    <span class="c1"># get the bounding box of the route.</span>
    <span class="c1">#shape_bounds = get_bounding_box(shapely.LineString(list(geometry)))</span>
    

    <span class="n">shape_bounds</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">))</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">3e-4</span><span class="p">)</span>
        
    <span class="c1"># get the speed limit data from the shapefile</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loading shapefile &amp; setting EPSG: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">limit_data_path</span><span class="p">))</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">pio</span><span class="o">.</span><span class="n">read_dataframe</span><span class="p">(</span><span class="n">limit_data_path</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="n">epsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Shapefile loaded with EPSG:</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epsg</span><span class="p">))</span>
    
    <span class="c1"># get the streets that are within the bounding box</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Filtering streets...&quot;</span><span class="p">)</span>
    <span class="n">bound_streets</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="n">limits</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shape_bounds</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">geometry</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">][[</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Streets filtered.&quot;</span><span class="p">)</span>

    <span class="c1"># set up list.</span>
    <span class="n">limit_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bound_streets</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># loop through the geometry:</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Processing speed limits...&quot;</span><span class="p">)</span>
    <span class="c1">#with alive_bar(len(geometry)) as bar:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">))):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># get the speed limit at the point through checking that the distance is within the margin. Use first value that appears.</span>
        <span class="c1">#bound_streets[&#39;range&#39;] = bound_streets.geometry.apply(lambda x: x.buffer(margin))</span>
        <span class="n">bound_streets</span><span class="p">[</span><span class="s1">&#39;contains_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_streets</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">margin</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
        <span class="n">matches_street</span> <span class="o">=</span> <span class="n">bound_streets</span><span class="p">[</span><span class="n">bound_streets</span><span class="p">[</span><span class="s1">&#39;contains_point&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>

        <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_street</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">matches_street</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>



        <span class="c1"># append the limit to the list.</span>
        <span class="n">limit_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span><span class="o">*</span><span class="mf">0.00044704</span><span class="p">)</span>
            <span class="c1">#bar()</span>
    
    <span class="c1"># while there is a speed limit of zero, swap them out for the next nearest speed limit that isn&#39;t zero</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">limit_list</span><span class="p">):</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="n">limit_list</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limit_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Filling gaps: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remaining</span><span class="p">),</span> <span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">limit_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">limit_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_known_limit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last_known_limit</span> <span class="o">=</span> <span class="n">limit_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Speed limits processed. Returning values.&quot;</span><span class="p">)</span>


    <span class="c1"># return the limit list, converted to km/s</span>
    <span class="k">return</span> <span class="n">limit_list</span></div>



<div class="viewcode-block" id="query_bearings">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_bearings">[docs]</a>
<span class="k">def</span> <span class="nf">query_bearings</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">bearing_type</span> <span class="o">=</span> <span class="s2">&quot;Angle&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_bearings takes a geometric iterable of shapely points,</span>
<span class="sd">    and returns the corresponding bearing when travelling form one point to the next.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    geometry - a series of shapely points of lat and lon</span>
<span class="sd">    bearing_type - determine the bearing output. Options: Angle - return the angle in degrees. Compass - return the angle as a directional bearing (eg: N, E, S, W)</span>
<span class="sd">    verbose - boolean to enable verbosity. Default False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of bearings when travelling to subsequent point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get the current geometry series</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Loading geometry.&quot;</span><span class="p">)</span>
    <span class="n">currents</span> <span class="o">=</span> <span class="n">geometry</span>
    
    <span class="c1"># shift the geometry series up by one, which will be the next ponts.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Shifting geometry.&quot;</span><span class="p">)</span>
    <span class="n">nexts</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># combine the two into a dataframe.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Combining geometry.&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">currents</span><span class="p">,</span> <span class="n">nexts</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># get the initial point and make sure it&#39;s the first value.</span>
    <span class="n">final_point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># set the nan value in the beginning of the &#39;nexts&#39; to the initial, representing no distance traveled.</span>
    <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">final_point</span>

    <span class="c1"># apply the geodesic formula to the data, which will yeild a series of changes in distance.</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Calculating bearings.&quot;</span><span class="p">)</span>
    <span class="n">bearings</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">point_bearing</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bearing_type</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Bearings processed. Returning values.&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">bearings</span></div>


    
    

<span class="c1">### ---- ELEVATION TOOLS ---- ###</span>

<div class="viewcode-block" id="get_rasterfiles">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.get_rasterfiles">[docs]</a>
<span class="k">def</span> <span class="nf">get_rasterfiles</span><span class="p">(</span><span class="n">dir_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get_rasterfiles takes a path to a directory and returns a series of paths to any .tif files</span>
<span class="sd">    contained therin.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    dir_path - path to directory, as str. </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    pandas series of path strings to each .tif file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># create a series using the list of items in the specified directory</span>
    <span class="n">rasterfiles_raw</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dir_path</span><span class="p">))</span>
    
    <span class="c1"># filter the list to only be those that contain tif. </span>
    <span class="n">rasterfiles_raw</span> <span class="o">=</span> <span class="n">rasterfiles_raw</span><span class="p">[</span><span class="n">rasterfiles_raw</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;tif&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
    <span class="n">rasterfiles</span> <span class="o">=</span> <span class="n">rasterfiles_raw</span><span class="p">[</span><span class="n">rasterfiles_raw</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;.tif_&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
    <span class="c1"># convert the paths to have the full path rather than just the filenames.</span>
    <span class="n">rasterfiles</span> <span class="o">=</span> <span class="n">rasterfiles</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    
    <span class="c1"># return the series.</span>
    <span class="k">return</span> <span class="n">rasterfiles</span></div>



<div class="viewcode-block" id="reproject_rasterfiles">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.reproject_rasterfiles">[docs]</a>
<span class="k">def</span> <span class="nf">reproject_rasterfiles</span><span class="p">(</span><span class="n">filepath_sequence</span><span class="p">,</span> <span class="n">target_crs</span><span class="o">=</span><span class="s1">&#39;EPSG:4326&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reproject_rasterfiles takes an iterable of geotiff files, and</span>
<span class="sd">    then reprojects them as a target crs and saves them in the same</span>
<span class="sd">    directory as the original.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    filepath_sequence - an iterable of filepaths to geotiff files.</span>
<span class="sd">    target_crs - the projection system the rasterfiles are to be re-projected to.</span>
<span class="sd">    verbose - specify if the output is verbose. Boolean default False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    iterable sequence of the newly reprojected files.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    11/14/2024 - This should be made to have the ability to override if requested. For now, leaving it as-is is fine.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># adjust the reprojection so it can be saved properly:</span>
    <span class="n">crs_split</span> <span class="o">=</span> <span class="n">target_crs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
    <span class="n">crs_string</span> <span class="o">=</span> <span class="n">crs_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">crs_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Reprojecting raster files to: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_crs</span><span class="p">))</span>
    <span class="c1">#with alive_bar(len(filepath_sequence)) as bar:</span>
    <span class="c1"># Loop through each file in the iterable</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">filepath_sequence</span><span class="p">):</span>

        <span class="c1">#Check if the reprojection is already there.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.tif&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crs_string</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crs_string</span><span class="p">))</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)):</span>

            <span class="c1"># open the current rasterfile.</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># use rasterIO to calculate the transform of the file to the desired crs</span>
                <span class="n">transform</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">calculate_default_transform</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                                                                                     <span class="n">target_crs</span><span class="p">,</span>
                                                                                     <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                                                                                     <span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
                                                                                     <span class="o">*</span><span class="n">src</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
                <span class="c1"># copy the kwargs from the geotiff</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># update the kwargs with the target CRS</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                    <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">target_crs</span><span class="p">,</span>
                    <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
                    <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span>
                <span class="p">})</span>

                <span class="c1"># Create a reprojection file using the target crs</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="o">+</span><span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crs_string</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>

                    <span class="c1"># loop through the projections in src</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

                        <span class="c1"># reproject the values in the src.</span>
                        <span class="n">reproject</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">band</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                                                <span class="n">destination</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">band</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                                                <span class="n">src_transform</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                                                <span class="n">src_crs</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                                                <span class="n">dst_transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                                                <span class="n">dst_crs</span><span class="o">=</span><span class="n">target_crs</span><span class="p">,</span>
                                                <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span><span class="p">)</span>
        <span class="c1">#bar()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Raster files succesfully reprojected.&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">filepath_sequence</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.tif&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crs_string</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span></div>



<div class="viewcode-block" id="query_elevation_series">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.query_elevation_series">[docs]</a>
<span class="k">def</span> <span class="nf">query_elevation_series</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gtiff_dir_ser</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    query_elevation_series takes a series of geometric shapely points, and an iterable of</span>
<span class="sd">    geotiff filepaths, and generates a pandas series of elevations from each point in</span>
<span class="sd">    the geometry.</span>
<span class="sd">    Also for some reason tifs store lat and long in (lon, lat), so i swap em.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Params: </span>
<span class="sd">    geometry - a series of shapely points of lat and lon</span>
<span class="sd">    gtiff_dir_ser - an iterable of geometric shapely points. Must have an identical projection to the raster files.</span>
<span class="sd">    verbose - boolean parameter to specify verbosity. Defualt False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    pandas series of elevations corresponding to the geometry iterable, in km.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Generate the empty dictionary</span>
    <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># make sure the geometry is a series.</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Converting geometry...&quot;</span><span class="p">)</span>
    <span class="c1"># Convert the geometry to individual lat/lon tuples</span>
    <span class="n">route_ll</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Geometry converted.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Querying elevation data...&quot;</span><span class="p">)</span>
    <span class="c1"># loop through each geotiff file in the series passed</span>
        
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">gtiff_dir_ser</span><span class="p">):</span>

        <span class="c1"># Use rasterio to open the file</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">img</span><span class="p">:</span>

            <span class="c1"># sample the elevations using rasterio and the list of lats and lons.</span>
            <span class="n">route</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rasterio</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">sample_gen</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">route_ll</span><span class="p">),</span> <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>


            <span class="c1"># remove any masked values</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="n">route</span><span class="p">[</span><span class="n">route</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="o">!=</span> <span class="s2">&quot;&lt;class &#39;numpy.ma.core.MaskedConstant&#39;&gt;&quot;</span><span class="p">]</span>

            <span class="c1"># loop through the index of the filtered values</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">filtered</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>

                <span class="c1"># add the filtered value to the data dictionary at the index corresponding to</span>
                <span class="c1"># its respective point.</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">verbose_line_updater</span><span class="p">(</span><span class="s2">&quot;Elevation succesfully queried. Returning values.&quot;</span><span class="p">)</span>
                
    <span class="c1"># convert to series</span>
    <span class="n">data_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    
    <span class="c1"># sort the data by index</span>
    <span class="n">data_sorted</span> <span class="o">=</span> <span class="n">data_series</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
    
    <span class="c1"># convert to km</span>
    <span class="n">data_valued</span> <span class="o">=</span> <span class="n">data_sorted</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">/</span><span class="mi">1000</span>
    
    <span class="c1"># return</span>
    <span class="k">return</span> <span class="n">data_valued</span></div>





<div class="viewcode-block" id="smooth_elevation">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.smooth_elevation">[docs]</a>
<span class="k">def</span> <span class="nf">smooth_elevation</span><span class="p">(</span><span class="n">elev_series</span><span class="p">,</span> <span class="n">lg</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">43</span><span class="p">,</span> <span class="n">deg</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>

        <span class="c1"># Apply the savgol filter to the points</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">elev_series</span><span class="p">,</span>
                   <span class="n">lg</span><span class="p">,</span>
                   <span class="n">deg</span><span class="p">,</span>
                   <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y_new</span></div>



<span class="c1">### ---- Processing Tools ---- ###</span>


<span class="k">def</span> <span class="nf">_combine_lidar_data</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">max_grade</span><span class="o">=</span><span class="mf">7.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    combine_lidar_data takes dsm elevation series, as well as the change in distance</span>
<span class="sd">    between the points, and generates a filtered elevation that provides cleaner road elevation.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    dsm - digital surface model elevation iterable.</span>
<span class="sd">    dtm - digital terrain model elevation iterable.</span>
<span class="sd">    dx - iterable change in distance, in kilometers.</span>
<span class="sd">    max_grade - maximum possible grade the road can achieve. Default int=7.5.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    iterable of filtered elevations, in km.</span>
<span class="sd">    </span>
<span class="sd">    Note: </span>
<span class="sd">    1/16/2025 - Made private, as it is not strictly nessecary for functionality right now. Also, writing a test for this sounds like a headache.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># combine the dsm and dx into a dataframe</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dsm</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dx</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dsm&#39;</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># calculate the rolling dsm median</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rolling_dsm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dsm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">())</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># calculate the difference in elevation</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dsm_dy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dsm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>

    <span class="c1"># get the filtered elevation. </span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dsm_dy</span><span class="o">/</span><span class="n">x</span><span class="o">.</span><span class="n">dx</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">&gt;</span><span class="n">max_grade</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">rolling_dsm</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dsm_dy</span><span class="o">/</span><span class="n">x</span><span class="o">.</span><span class="n">dx</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">max_grade</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">dsm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># return the values.</span>
    <span class="k">return</span> <span class="n">filtered</span><span class="o">.</span><span class="n">values</span>


<div class="viewcode-block" id="calculate_grades">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.calculate_grades">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_grades</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">elevations</span><span class="p">,</span> <span class="n">clip</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">,</span> <span class="n">max_grade</span><span class="o">=</span><span class="mf">7.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate_grades takes the distance between points,</span>
<span class="sd">    as well as the elevations at each point, and returns the grade at each point.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    dx - an iterable of distances between each point</span>
<span class="sd">    elevations - an iterable of elevations corresponding to each point.</span>
<span class="sd">    clip - boolean to determine to clip the grades or not. Default True.</span>
<span class="sd">    max_grade - an int representing the maximum grade a point can be without being clipped to. Default 7.5</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    iterable of the slope grade at each point. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate the grade percentage using the elevation difference and distance difference,</span>
    <span class="n">grades</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">elevations</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">/</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># ensure only finite values</span>
    <span class="n">gradeindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">grades</span><span class="p">)</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">grades</span><span class="p">[</span><span class="n">gradeindex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">max_grade</span>
    <span class="n">grades</span> <span class="o">=</span> <span class="n">grades</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">grades</span><span class="p">)]</span>

    <span class="c1"># check to clip the values</span>
    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="n">grades</span> <span class="o">=</span> <span class="n">grades</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_grade</span><span class="p">,</span> <span class="o">-</span><span class="n">max_grade</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grades</span><span class="o">=</span><span class="n">grades</span>


    <span class="n">grades</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grades</span><span class="p">)</span>
    <span class="n">grades</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">grades</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


    <span class="c1"># return the grade.</span>
    <span class="k">return</span> <span class="n">grades</span></div>



<div class="viewcode-block" id="interpolate_geometry_series">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.interpolate_geometry_series">[docs]</a>
<span class="k">def</span> <span class="nf">interpolate_geometry_series</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">max_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    interpolate_geometry_series takes an iterable of geospatial shapely points,</span>
<span class="sd">    and then generates an interpolated series in the event that</span>
<span class="sd">    the maximum distance (in meters) is exceeded.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    geometry - a series of shapely points of lat and lon</span>
<span class="sd">    max_distance - int representing maximum distance the points can be without interpolation</span>
<span class="sd">                   </span>
<span class="sd">    Returns:</span>
<span class="sd">    iterable of lists of shapely points that have been interpolated.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">currents</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
    
    <span class="c1"># shift the geometry series up by one, which will be the next ponts.</span>
    <span class="n">nexts</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># combine the two into a dataframe.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">currents</span><span class="p">,</span> <span class="n">nexts</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># get the initial point and make sure it&#39;s the final value.</span>
    <span class="n">final_point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># set the nan value in the beginning of the &#39;nexts&#39; to the initial, representing no distance traveled.</span>
    <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">final_point</span>
    <span class="c1"># interpolate the points</span>
    
    <span class="n">grace</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">interpolate_points</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">max_distance</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># explode the data so that its a cohesive series</span>
    <span class="n">sploded</span> <span class="o">=</span> <span class="n">grace</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># return an iterable of the interpolated points at each index</span>
    <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">sploded</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_interpolate_distance_traveled</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">interpolated_iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Notes:</span>
<span class="sd">    1/16/2025 - Not strictly nessecary. Privated. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dx</span><span class="p">),</span> <span class="n">interpolated_iterable</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="s1">&#39;i_i&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">interp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">dx</span><span class="o">/</span><span class="n">x</span><span class="o">.</span><span class="n">i_i</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">i_i</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">interp</span>


        
        
    
<span class="c1">### ---- Class, Saving, and Inter-operability tools ---- ###</span>
<div class="viewcode-block" id="Route">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.Route">[docs]</a>
<span class="k">class</span> <span class="nc">Route</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Route class is is used to store route information. </span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    geometry - iterable of shapely geometry points</span>
<span class="sd">    elevation - iterable of elevation data</span>
<span class="sd">    limits - iterable of speed limit at each point. (optional, defaults to 25mph in km/s)</span>
<span class="sd">    stops - iterable of stop flags at each point. (optional, defaults to 10 evenly spaced stops.)</span>
<span class="sd">    signals - iterable of signal flags at each point. (optional, defaults to 8 evenly spaced signals.)</span>
<span class="sd">    signs - iterable of sign flags at each point. (optional, defaults to 3 evenly spaced stop signs.)</span>
<span class="sd">    intersperse_empty - boolean flag to intersperse any empty parameters. Default False.</span>
<span class="sd">    </span>
<span class="sd">    Methods: </span>
<span class="sd">    save_to_json() - saves the stored data to a json file. can be loaded again with Geography Tools&#39; load_from_json.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">geometry</span><span class="p">,</span>
                 <span class="n">elevation</span><span class="p">,</span>
                 <span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">stops</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">signals</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">signs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">intersperse_empty</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">smooth_grades</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        
        <span class="c1"># set up the params list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">geometry</span><span class="p">),</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">stops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">signals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">signs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="n">intersperse_empty</span><span class="p">,</span>
                        <span class="n">smooth_grades</span><span class="p">]</span>
        
        <span class="c1"># initialize geometry and elevation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elevation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span>
        
        <span class="c1"># get length of passed geometry</span>
        <span class="n">geolen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
        
        <span class="c1"># if limits is empty, use 25mph (in km/s) as default.</span>
        <span class="k">if</span> <span class="n">limits</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="mi">25</span><span class="o">/</span><span class="mf">2236.936</span><span class="p">,</span> <span class="n">geolen</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>
        
        <span class="c1"># if stops is empty, populate with -1, then intersperse with 10 stops (number of timepoints per route)</span>
        <span class="k">if</span> <span class="n">stops</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">intersperse_empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geolen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geolen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stops</span><span class="p">)</span>
        
        <span class="c1"># if signals is empty, intersperse with 10 signals.</span>
        <span class="k">if</span> <span class="n">signals</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">intersperse_empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geolen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geolen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">signals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signals</span><span class="p">)</span>
        
         <span class="c1"># if signs is empty, intersperse with 3 signs.</span>
        <span class="k">if</span> <span class="n">signs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">intersperse_empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">signs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geolen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">signs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersperse_list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geolen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">signs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signs</span><span class="p">)</span>
        
        <span class="c1"># calculate the bearings, distance changes, and grades.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bearings</span> <span class="o">=</span> <span class="n">query_bearings</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">),</span> <span class="n">bearing_type</span><span class="o">=</span><span class="s2">&quot;Compass&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">query_distance_traveled</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="n">query_elevation_changes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elevation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cum_d_X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_X</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grades</span> <span class="o">=</span> <span class="n">calculate_grades</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">elevation</span><span class="p">,</span> <span class="n">max_grade</span><span class="o">=</span><span class="mf">7.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smooth_grades</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grades</span> <span class="o">=</span> <span class="n">smooth_elevation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grades</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        
        
        <span class="c1"># return None</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Route(l:</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    
    
    <span class="k">def</span> <span class="nf">_intersperse_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">list_size</span><span class="p">,</span> <span class="n">intersperse_val</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">intersperse_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        intersperse_list() is used to generate a list of point-based flags of a given value,</span>
<span class="sd">        with the option to evenly intersperse those values with an alternate flag. </span>
<span class="sd">        </span>
<span class="sd">        Params:</span>
<span class="sd">        default_value - the value that the list will be populated with initially.</span>
<span class="sd">        list_size - size of the list to be made, as an int.</span>
<span class="sd">        intersperse_val - value to be interspersed, default of -1.</span>
<span class="sd">        intersperse_num - number of ocurrences of the interspersed value, as int. Default 0.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        the new list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Generate a new list of target size filled with target value.</span>
        <span class="n">new_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_value</span><span class="p">]</span><span class="o">*</span><span class="n">list_size</span>
        
        <span class="c1"># loop through and intersperse the desired value.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intersperse_num</span><span class="p">):</span>
            <span class="n">new_list</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">list_size</span><span class="o">/</span><span class="n">intersperse_num</span><span class="p">))]</span> <span class="o">=</span> <span class="n">intersperse_val</span>
        
        <span class="c1"># return the new list. </span>
        <span class="k">return</span> <span class="n">new_list</span>
    
    
<div class="viewcode-block" id="Route.save_to_json">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.Route.save_to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">save_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        save_to_json() is used to encode and save the Route data to a json file.</span>
<span class="sd">        </span>
<span class="sd">        Params:</span>
<span class="sd">        path - path and filename to be saved to, as str. Should end with &#39;.json&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        path to the saved json file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># generate data dictionary and compress the data where possible.</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ge&#39;</span><span class="p">:</span><span class="n">_encode_geometry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">),</span>
                     <span class="s1">&#39;el&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">elevation</span><span class="p">,</span>
                     <span class="s1">&#39;li&#39;</span><span class="p">:</span><span class="n">_encode_series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">),</span>
                     <span class="s1">&#39;st&#39;</span><span class="p">:</span><span class="n">_encode_series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">),</span>
                     <span class="s1">&#39;si&#39;</span><span class="p">:</span><span class="n">_encode_series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signals</span><span class="p">),</span>
                     <span class="s1">&#39;sn&#39;</span><span class="p">:</span><span class="n">_encode_series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signs</span><span class="p">)}</span>
        
        <span class="c1"># Open and save to the json. encode in utf-8 for funsies.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            
            <span class="c1"># save the data.</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ensure_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="c1"># return the path.</span>
        <span class="k">return</span> <span class="n">path</span></div>

    
    
<div class="viewcode-block" id="Route.query_point">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.Route.query_point">[docs]</a>
    <span class="k">def</span> <span class="nf">query_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        query_point() takes an index of a point and returns the data for the corresponding point.</span>
<span class="sd">        </span>
<span class="sd">        Params:</span>
<span class="sd">        index - index of the route which data you would like to query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;elevation&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">elevation</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;limit&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;stop&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;signal&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">signals</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;sign&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">signs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;bearing&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">bearings</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;grade&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">grades</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;dx_to_next&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="c1"># geodesic distance</span>
                <span class="s1">&#39;dz_to_next&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;travel_dx&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">d_X</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="s1">&#39;sum_travel_dx&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">cum_d_X</span><span class="p">[</span><span class="n">index</span><span class="p">]}</span>
        
        <span class="k">return</span> <span class="n">data</span></div>

    
    
<div class="viewcode-block" id="Route.to_gdf">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.Route.to_gdf">[docs]</a>
    <span class="k">def</span> <span class="nf">to_gdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        to_gdf() takes the constituent information in geography_tools and converts it to a geodataframe.</span>
<span class="sd">        </span>
<span class="sd">        Params:</span>
<span class="sd">        N/A</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        geodataframe of all information contained by a Route object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                <span class="s1">&#39;elevation&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">elevation</span><span class="p">,</span>
                <span class="s1">&#39;limit&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">,</span>
                <span class="s1">&#39;stop&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">,</span>
                <span class="s1">&#39;signal&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">signals</span><span class="p">,</span>
                <span class="s1">&#39;sign&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">signs</span><span class="p">,</span>
                <span class="s1">&#39;bearing&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">bearings</span><span class="p">,</span>
                <span class="s1">&#39;grade&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">grades</span><span class="p">,</span>
                <span class="s1">&#39;dx_to_next&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="c1"># geodesic distance</span>
                <span class="s1">&#39;dz_to_next&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span>
                <span class="s1">&#39;travel_dx&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">d_X</span><span class="p">,</span>
                <span class="s1">&#39;sum_travel_dx&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">cum_d_X</span><span class="p">}</span>
        
        <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>
</div>

        
            

<span class="k">def</span> <span class="nf">_encode_series</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    encode_series() takes an iterable and compresses it down so that </span>
<span class="sd">    repeating values are stored as the value and number of occurrences.</span>
<span class="sd">    Warning: Value typings will be lost.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    iterable - an iterable list of values.</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">    a string representation of the compressed information. </span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    1/16/2025 - Privated since it isn&#39;t needed externally. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># get the first item of the iterable</span>
    <span class="n">current_item</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># set the current item count to negative to avoid indexing errors.</span>
    <span class="n">current_item_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># create an empty string.</span>
    <span class="n">data_stream</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    
    <span class="c1"># loop through each position in the iterable</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="c1"># if the index is at the end of the iterable,</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># add by 1 and subsequently add the current item and count to the string.</span>
            <span class="n">current_item_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">data_stream</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_item_count</span><span class="p">,</span> <span class="n">current_item</span><span class="p">))</span>
        
        <span class="c1"># otherwise,</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="c1"># the selected item is the current position in the iterable</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># and if the items are the same,</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">current_item</span><span class="p">:</span>
                
                <span class="c1"># increment the count by 1.</span>
                <span class="n">current_item_count</span> <span class="o">+=</span> <span class="mi">1</span>
                
            <span class="c1"># otherwise,</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="c1"># increment the count and add it to the stream.</span>
                <span class="n">current_item_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">data_stream</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_item_count</span><span class="p">,</span> <span class="n">current_item</span><span class="p">))</span>
                
                <span class="c1"># reset the count and set the new item.</span>
                <span class="n">current_item_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">current_item</span> <span class="o">=</span> <span class="n">item</span>

    <span class="c1"># return the encoded representation.</span>
    <span class="k">return</span> <span class="n">data_stream</span>


<span class="k">def</span> <span class="nf">_decode_series</span><span class="p">(</span><span class="n">encoded_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    decode_series() takes in a string that was encoded using encode_series(), </span>
<span class="sd">    and returns it to a decoded iterable. </span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    encoded_string - string that was encoded using encode_series()</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    an iterable of the decompressed information. </span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    1/16/2025 - Privated since it isn&#39;t needed externally. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># split the string by comma.</span>
    <span class="n">spliterable</span> <span class="o">=</span> <span class="n">encoded_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    
    <span class="c1"># create an empty list to contain the data.</span>
    <span class="n">joint_iterable</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># for every two items, join them into a tuple and append it to the list.</span>
    <span class="k">for</span> <span class="n">item1</span><span class="p">,</span> <span class="n">item2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spliterable</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">spliterable</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">joint_iterable</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">))</span>
        
    <span class="c1"># create an empty list for the decoded information.</span>
    <span class="n">decoded_iterable</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># loop through each item in the joint iterable</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">joint_iterable</span><span class="p">:</span>
        
        <span class="c1"># repeatedly add the encoded item for the number of occurences it has.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">decoded_iterable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
    <span class="c1"># return the list. </span>
    <span class="k">return</span> <span class="n">decoded_iterable</span>


<span class="k">def</span> <span class="nf">_encode_geometry</span><span class="p">(</span><span class="n">geo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    encode_geometry() takes in an iterable of shapely points,</span>
<span class="sd">    and then converts it to a list of alternating x and y values.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    geo - iterable of shapely points.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of alternating X and Y values in the same order as geo.</span>
<span class="sd">        Notes:</span>
<span class="sd">    1/16/2025 - Privated since it isn&#39;t needed externally. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># create an empty list</span>
    <span class="n">clist</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># loop through the geometry and get the X and Y values,</span>
    <span class="c1"># and extend the list with them.</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">geo</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">]):</span>
        <span class="n">clist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        
    <span class="c1"># return the list.</span>
    <span class="k">return</span> <span class="n">clist</span>


<span class="k">def</span> <span class="nf">_decode_geometry</span><span class="p">(</span><span class="n">enc_geo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    decode_geometry() takes in compressed geometry from encode_geometry(),</span>
<span class="sd">    and converts it to an iterable of shapely points.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    enc_geo - encoded geometry list.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    list of shapely geometry.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">    1/16/2025 - Privated since it isn&#39;t needed externally. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># empty list to store data</span>
    <span class="n">point_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># loop through every 2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_geo</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># if even index, it&#39;s x, odd is y.</span>
        <span class="c1"># append the point.</span>
        <span class="n">point_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">([</span><span class="n">enc_geo</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">enc_geo</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]))</span>
    
    <span class="c1"># return the list.</span>
    <span class="k">return</span> <span class="n">point_list</span>
            

<div class="viewcode-block" id="load_from_json">
<a class="viewcode-back" href="../../reRoute_Dynamics.html#reRoute_Dynamics.Geography_Tools.load_from_json">[docs]</a>
<span class="k">def</span> <span class="nf">load_from_json</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    load_from_json() takes in a path to a json file from an exported Route object,</span>
<span class="sd">    and returns a path object as close as possible to what was saved.</span>
<span class="sd">    Waring: Some data types may be altered or adjusted. Speed limits are expected to be floats, stops, signals, signs, are expected to be ints.</span>
<span class="sd">    </span>
<span class="sd">    Params:</span>
<span class="sd">    path - path to json file.</span>
<span class="sd">    </span>
<span class="sd">    Returns: a Route object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># create empty data dictionary.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># open the file.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        
        <span class="c1"># load the data.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    
    <span class="c1"># read the geometry data</span>
    <span class="n">geo</span> <span class="o">=</span> <span class="n">_decode_geometry</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge&#39;</span><span class="p">])</span>
    
    <span class="c1"># read the elevation data</span>
    <span class="n">el</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;el&#39;</span><span class="p">]</span>

    <span class="c1"># read the limit, stop, signal, and sign data</span>
    <span class="n">lim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_decode_series</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;li&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
    <span class="n">stp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_decode_series</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">signals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_decode_series</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;si&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">signs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_decode_series</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    
    <span class="c1"># generate a new Route object from the provided data. </span>
    <span class="n">loaded_route</span> <span class="o">=</span> <span class="n">Route</span><span class="p">(</span><span class="n">geo</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">lim</span><span class="p">,</span> <span class="n">stp</span><span class="p">,</span> <span class="n">signals</span><span class="p">,</span> <span class="n">signs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loaded_route</span></div>

    
    
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Sebastian Peck.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>